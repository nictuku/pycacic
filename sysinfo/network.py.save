#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""Provides network information
"""

import commands 
import logging
import re
import socket
import struct

class interfaces:
    """Shows interfaces data. 
       
interf_dict provides a list of interfaces and their respective raw
"ifconfig" data.
    """

    interf_dict = {}

    def __init__(self):
	ifconfig = commands.getstatusoutput("export LANG=C; /sbin/ifconfig")
	if ifconfig[0] != 0:
	    logging.error("Erro ao executar ifconfig")
	    raise 
	else:
	    i = ifconfig[1]
	    sp = re.compile('([ae]th[\d]+|lo) ')
	    interf_list = sp.split(i)
	    interf_list.pop(0)
	    #print interf_list, "aaaaaa"
	    i = 1
	    for x in interf_list:
		if i % 2 == 0: # PARES
		    self.interf_dict[ interf_list[i - 2] ] = x
		i += 1

    def hostname(self):
        """Returns current hostname
        """
        return socket.gethostname()

    def mac_address(self,interf):
        """Gives network interfaces hardware address
        """
        #print "Ifconfig:", ifconfig[1]
        h = re.compile(r'HW(addr)? (?P<mac>[\w:]+) ', re.I)
        w = h.search(self.interf_dict[interf])
        mac = w.group('mac')
        return mac

    def ip_addr(self,interf):
        """Shows the interface's respective IP addresses
        """
        h = re.compile(r'inet add?r:(?P<ip_addr>[\w.]+)', re.I)
        w = h.search(self.interf_dict[interf])
        ip_addr = w.group('ip_addr')
        return ip_addr


    def status(self,interf):
        """Shows interface status
        """
        h = re.compile('UP',re.I)
        w = h.search(self.interf_dict[interf])
        if w:
             return 'UP'
        else:
             return 'DOWN'

    def getDHCPServer(self,interf):
        """Return the current DHCP Server for the 'interf' interface, by parsing the dhclient.leases file.
        In case there are many leases stored, it should consider the last one for the given interface.
        """
        try:
            f = open('/var/lib/dhcp/dhclient.leases')
        except:
            pass
            try: 
                f = open('/var/lib/dhcp3/dhclient.leases')
            except:
                return false
        
        dhcp = f.read()
        
        sp = re.compile('(lease)\s*{')
        leases_list = sp.split(dhcp)

        test_int = re.compile('interface\s*"'+ interf)

        # remove leases unrelated to 'interf'
        for x in leases_list:
            m = test_int.search(x)
            if not m:
               leases_list.remove(x)

        lease = leases_list[len(leases_list) - 1 ]

        o = re.compile('option\s+dhcp-server-identifier\s+(?P<dhcp_server>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\s*;')
        k = o.search(lease)
        server = k.group('dhcp_server')

        return server
        # shows the last lease

    def getDNSResolver(self):
        try:
            f = open('/etc/resolv.conf','r')
        except:
            return false
        m = re.compile('\s*(?P<
        
 
    def getDefaultGateway(self):
        t1 = self.getDefaultGatewayFromProc()
        if not t1:
            t1 = self.getDefaultGatewayFromBinRoute()
            if not t1:
               return false
        return t1



    # Functions called by getDefaultGateway

    def getDefaultGatewayFromProc(self):
        """"Returns the current default gateway, reading that from /proc'
        """
        try:
            f = open('/proc/net/route','r')
            route = f.read()
        except:
            return false
        else:
            h = re.compile('\n(?P<interface>\w+)\s+00000000\s+(?P<def_gateway>[\w]+)\s+')
            w = h.search(route)
            if w.group('def_gateway'):
                return self.numToDottedQuad(self.hex2dec(w.group('def_gateway')))
            else:
                return false

            logging.warning('Could not read default gateway from /proc')

    def getDefaultGatewayFromBinRoute(self):
        """Get Default Gateway from '/sbin/route -n
        Called by getDefaultGateway and is only used if could not get that from /proc
        """
        routebin = commands.getstatusoutput("export LANG=C; /sbin/route -n")

        if routebin[0] != 0:
            logging.error("Erro while trying to run route")
            return false
        h = re.compile('\n0.0.0.0\s+(?P<def_gateway>[\w.]+)\s+')
        w = h.search(routebin[1])

        def_gateway = w.group('def_gateway')

        if def_gateway:
            return def_gateway

    # Auxiliary functions

    def hex2dec(self,s):
        """Returns the integer value of a hexadecimal string s
        """
        return int(s, 16)

    # Functions based on:
    # http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/66517
    # which is licensed under the BSD license.

    def dottedQuadToNum(self,ip):
        "convert decimal dotted quad string to long integer"
        return struct.unpack('L',socket.inet_aton(ip))[0]

    def numToDottedQuad(self,n):
        "convert long int to dotted quad string"
        return socket.inet_ntoa(struct.pack('L',n))

    def ipToNetAndHost(self,ip, maskstring):
        "returns tuple (network, host) dotted-quad addresses given IP and mask"
    # (by Greg Jorgensen)

        n = self.dottedQuadToNum(ip)
        m = self.dottedQuadToNum(maskstring)

        host = n & m
        net = n - host

        return self.numToDottedQuad(net), self.numToDottedQuad(host)
